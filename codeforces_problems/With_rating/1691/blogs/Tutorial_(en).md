# Tutorial_(en)

[1691A - Beat The Odds](../problems/A._Beat_The_Odds.md "CodeCraft-22 and Codeforces Round 795 (Div. 2)")
========================================================================================================================

**[Video Editorial](https://codeforces.com/https://youtu.be/CwsYQXjIwDg)**  
**Idea:** [amul_agrawal](https://codeforces.com/profile/amul_agrawal "Master amul_agrawal")  
**Problem Setting:** [menavlikar.rutvij](https://codeforces.com/profile/menavlikar.rutvij "Expert menavlikar.rutvij") [JadeReaper](https://codeforces.com/profile/JadeReaper "Expert JadeReaper") [rahulgoel](https://codeforces.com/profile/rahulgoel "Expert rahulgoel") [amul_agrawal](https://codeforces.com/profile/amul_agrawal "Master amul_agrawal")  
**Editorial**: [menavlikar.rutvij](https://codeforces.com/profile/menavlikar.rutvij "Expert menavlikar.rutvij") [rahulgoel](https://codeforces.com/profile/rahulgoel "Expert rahulgoel")  
**Video Editorial**: [rahulgoel](https://codeforces.com/profile/rahulgoel "Expert rahulgoel")

 **Hint 1**Sum of two odd numbers is even and sum of two even numbers is also even.

 **Hint 2**If all consecutive pairs have even sum, can we generalize something about the sequence using the above hint?

 **Solution**
### [1691A - Beat The Odds](../problems/A._Beat_The_Odds.md "CodeCraft-22 and Codeforces Round 795 (Div. 2)")

The sum of an odd integer and an even integer is an odd integer. So, you can't have both even and odd elements in the array for the sum of every two consecutive elements to be even.

Hence, the final array should only contain all even or all odd elements. Hence, we will remove either all odd elements or all even elements, whichever takes lesser number of operations. Therefore, the answer is: min(count of odd elements,count of even elements).

 **C++ Code**
```cpp
#include <bits/stdc++.h>
 
using namespace std;
 
int main()
{
	int t;
	cin >> t;
	while (t--)
	{
		int n;
		cin >> n;
		vector<int> a(n);
		for (int i = 0; i < n; ++i)
			cin >> a[i];
		int num_odd = 0;
		for (auto x : a)
			if (x & 1)
				num_odd++;
		cout << min(num_odd, n - num_odd) << endl;
	}
	return 0;
}
```
[1691B - Shoe Shuffling](../problems/B._Shoe_Shuffling.md "CodeCraft-22 and Codeforces Round 795 (Div. 2)")
=========================================================================================================================

**[Video Editorial](https://codeforces.com/https://youtu.be/ZA1qvxn7lP0)**  
**Idea:** [amul_agrawal](https://codeforces.com/profile/amul_agrawal "Master amul_agrawal")  
**Problem Setting:** [rahulgoel](https://codeforces.com/profile/rahulgoel "Expert rahulgoel") [menavlikar.rutvij](https://codeforces.com/profile/menavlikar.rutvij "Expert menavlikar.rutvij") [JadeReaper](https://codeforces.com/profile/JadeReaper "Expert JadeReaper")  
**Editorial**: [menavlikar.rutvij](https://codeforces.com/profile/menavlikar.rutvij "Expert menavlikar.rutvij") [rahulgoel](https://codeforces.com/profile/rahulgoel "Expert rahulgoel")  
**Video Editorial**: [JadeReaper](https://codeforces.com/profile/JadeReaper "Expert JadeReaper")

 **Hint 1**What happens to other people when a person receives a shoe greater his size?

 **Hint 2**What happens when a person has a unique shoe size?

 **Solution**
### [1691B - Shoe Shuffling](../problems/B._Shoe_Shuffling.md "CodeCraft-22 and Codeforces Round 795 (Div. 2)")

We can observe that the number of pairs of shoes greater than their size is limited for any student. So if student j wears shoes that are greater than their size, then some student i who has a size greater than student j will compromise their size. So say a valid shuffling exists where a student gets shoes of size greater than their own, i.e., student j got shoes of student i where si>sj. Then, for all pairs of shoes of size sj, one pair will go to a student whose size is smaller than sj. This chain will continue until a student with shoe size s1 gets a pair of shoes greater than theirs, and then there will exist a pair of shoes of size s1 that no student can wear. Thus, if a valid shuffling, every student must get shoes of the same size as their own.

Hence, a valid shuffling exists if more than one student has the same size shoes for all shoe sizes. A valid shuffling can be generated by rearranging students' shoes with the same shoe size such that no one gets their shoes. This can be done in multiple ways, for example, cyclic rotation.

 **C++ Code**
```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long
typedef vector<ll> vll;
#define io                            
    ios_base::sync_with_stdio(false); 
    cin.tie(NULL);                    
    cout.tie(NULL)

int main()
{
    io;
    ll tc;
    cin >> tc;
    while (tc--)
    {
        ll n;
        cin >> n;
        vll s(n), p(n);
        for (ll i = 0; i < n; ++i)
            cin >> s[i];

        ll l = 0, r = 0;
        bool ans = true;
        for (ll i = 0; i < n; ++i)
            p[i] = i + 1;

        while (r < n)
        {
            while (r < n - 1 and s[r] == s[r + 1]) // get range [l,r] with equal values
                ++r;
            if (l == r)
                ans = false;
            else
                rotate(p.begin() + l, p.begin() + r, p.begin() + r + 1); // rotate right in range [l,r]
            l = r + 1;
            ++r;
        }
        if (ans)
        {
            for (auto &x : p)
                cout << x << " ";
            cout << endl;
        }
        else
            cout << -1 << endl;
    }
    return 0;
}
```
[1691C - Sum of Substrings](../problems/C._Sum_of_Substrings.md "CodeCraft-22 and Codeforces Round 795 (Div. 2)")
============================================================================================================================

**[Video Editorial](https://codeforces.com/https://youtu.be/AP98uwI-R90)**  
**Idea:** [amul_agrawal](https://codeforces.com/profile/amul_agrawal "Master amul_agrawal")  
**Problem Setting:** [rahulgoel](https://codeforces.com/profile/rahulgoel "Expert rahulgoel") [amul_agrawal](https://codeforces.com/profile/amul_agrawal "Master amul_agrawal")  
**Editorial**: [amul_agrawal](https://codeforces.com/profile/amul_agrawal "Master amul_agrawal") [rahulgoel](https://codeforces.com/profile/rahulgoel "Expert rahulgoel")  
**Video Editorial**: [amul_agrawal](https://codeforces.com/profile/amul_agrawal "Master amul_agrawal")

 **Hint 1**What is the contribution of each `1`?

 **Hint 2**At what position would `1` contribute less?

 **Solution**
### [1691C - Sum of Substrings](../problems/C._Sum_of_Substrings.md "CodeCraft-22 and Codeforces Round 795 (Div. 2)")

We can observe that for any string s, F(s) can also be written as: F(s)=10×s1+11×s2+11×s3…11×sn−1+1×sn In the above equation, si is the integral face value of the ith character of the string s. We came to this equation by observing what ith character is contributing to the value of F(s). If the ith character is a '1', it will contribute a value of 1 to di−1 and a value of 10 to di.

Now, in order to minimize the value of F(s), we would want to put the 1s at position n first, then at position 1 and then anywhere in the middle of the string. In order to achieve the best configuration in at max k operations, we will try to move the last '1' at position n first, then with the remaining operations, we will try to move the first '1' at position 1. The remaining 1s can stay where they are as they will anyways be contributing a value of 11 no matter which position they take.

 **C++ Code**
```cpp
#include <bits/stdc++.h>
using namespace std;
 
int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);
  int t;
  cin >> t;
  while (t--) {
    int n, k;
    cin >> n >> k;
    string s;
    cin >> s;
    int ones = 0, p1_first = n, p1_last = -1;
    for (int p = 0; p < n; p++) {
      if (s[p] != '1')
        continue;
      ones += 1;
      if (p1_first == n)
        p1_first = p;
      p1_last = p;
    }
    int add = 0;
    // moving the last one to last position
    if (ones > 0 and (n - 1 - p1_last) <= k) {
      k -= (n - 1 - p1_last);
      add += 1;
      ones -= 1;
    }
    // moving the first one to first position
    if (ones > 0 and p1_first <= k) {
      k -= (p1_first);
      add += 10;
      ones -= 1;
    }
    cout << 11 * ones + add << "n";
  }
  return 0;
}

```
[1691D - Max GEQ Sum](../problems/D._Max_GEQ_Sum.md "CodeCraft-22 and Codeforces Round 795 (Div. 2)")
======================================================================================================================

**[Video Editorial](https://codeforces.com/https://youtu.be/ZH9AonbvPAA)**  
**Idea:** [amul_agrawal](https://codeforces.com/profile/amul_agrawal "Master amul_agrawal")  
**Problem Setting:** [fangahawk](https://codeforces.com/profile/fangahawk "Candidate Master fangahawk") [amul_agrawal](https://codeforces.com/profile/amul_agrawal "Master amul_agrawal") [rahulgoel](https://codeforces.com/profile/rahulgoel "Expert rahulgoel") [keyurchd_11](https://codeforces.com/profile/keyurchd_11 "Candidate Master keyurchd_11")  
**Editorial**: [fangahawk](https://codeforces.com/profile/fangahawk "Candidate Master fangahawk") [rahulgoel](https://codeforces.com/profile/rahulgoel "Expert rahulgoel")  
**Video Editorial**: [fangahawk](https://codeforces.com/profile/fangahawk "Candidate Master fangahawk")

 **Hint 1**If we have a list of subarrays where the element at index i is the max, which subarrays should we check to be sufficient? 

 **Hint 2**Checking subarrays which end or start at index i is sufficient, so we can optimize our solution with this observation as the basis.

 **Solution**
### [1691D - Max GEQ Sum](../problems/D._Max_GEQ_Sum.md "CodeCraft-22 and Codeforces Round 795 (Div. 2)")

Let's look at the problem from the perspective of each ai. We want to check whether the sum of the subarrays, where ai is the maximum element, exceeds ai or not.

Firstly, we must find out in which subarrays is ai the maximum. This involves finding the previous greater element index and the next greater element index of i, which can be done for all indices in O(n) using stacks. Take these indices as xi, yi. After computing this for every index, we'll know that ai is max in subarrays with starting index [xi+1,i] and ending index [i,yi−1].

Take (j,k), which represents the sum of a subarray which starts at index j and ends at index k, where j∈[xi+1,i], k∈[i,yi−1]. If (j,k)>ai, then (j,i−1)+(i,i)+(i+1,k)>ai, giving us (j,i−1)+(i+1,k)>0. Hence, at least one of the subarrays, (j,i−1) or (i+1,k) has a sum greater than 0, which implies that one of subarrays (j,i), (i,k) has sum greater than ai, so only checking subarrays which start or end at index i suffices.

Therefore, for an index i, we need to check subarrays (xi+1,i),(xi+2,i),…,(i−1,i), and subarrays (i,i+1),(i,i+2),…,(i,yi−1). Since we just care if any one of them exceed ai, finding the max of them is enough. This reduces to making a range query over the prefix sums and one over the suffix sums. The query on prefix sums would look like

max(i,yi−1)−prefix[i−1]>ai

Where max(i,yi−1) returns the max prefix sum in the given range. This query can be done using a segment tree in O(logn). If any of the queries is true, then we just have to output "NO", else output "YES".

With this we get the time complexity of the solution as O(nlogn).

 **C++ Code**
```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
 
const ll ninf = -1e15;
 
vector<int> nextGreater(vector<ll>& arr, int n) {
	stack<int> s;	
        vector<int> result(n, n);
	for (int i = 0; i < n; i++) {
		while (!s.empty() && arr[s.top()] < arr[i]) {
			result[s.top()] = i;	
			s.pop();
		}
		s.push(i);
	}
        return result;
}
 
vector<int> prevGreater(vector<ll>& arr, int n) {
	stack<int> s;	
        vector<int> result(n, -1);
	for (int i = n - 1; i >= 0; i--) {
		while (!s.empty() && arr[s.top()] < arr[i]) {
			result[s.top()] = i;	
			s.pop();
		}
		s.push(i);
	}
        return result;
}
 
ll query(vector<ll> &tree, int node, int ns, int ne, int qs, int qe) {
    if (qe < ns || qs > ne) return ninf;
    if (qs <= ns && ne <= qe) return tree[node];
 
    int mid = ns + (ne - ns) / 2;
    ll leftQuery = query(tree, 2 * node, ns, mid, qs, qe);
    ll rightQuery = query(tree, 2 * node + 1, mid + 1, ne, qs, qe);
    return max(leftQuery, rightQuery);
}
 
int main() {
   int t; 
   cin >> t;
   while (t--) {
        int n, _n;
        cin >> n;
        vector<ll> arr(n, 0);
        for (auto& a : arr)
            cin >> a;
        
        // Round off n to next power of 2
        _n = n;
        while (__builtin_popcount(_n) != 1) _n++;
 
 
        // Prefix sums
        vector<ll> prefixSum(n, 0), suffixSum(n, 0);
        prefixSum[0] = arr[0];
        for (int i = 1; i < n; i++) {
            prefixSum[i] = prefixSum[i - 1] + arr[i];
        }
        suffixSum[n - 1] = arr[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            suffixSum[i] = suffixSum[i + 1] + arr[i];
        }
        
        // Two max-segtress, one on the prefix sums, one on the suffix sums
        vector<ll> prefixTree(2 * _n, ninf), suffixTree(2 * _n, ninf);
 
        for (int i = 0; i < n; i++) {
            prefixTree[_n + i] = prefixSum[i];
            suffixTree[_n + i] = suffixSum[i];
        }
 
        for (int i = _n - 1; i >= 1; i--) {
            prefixTree[i] = max(prefixTree[2 * i], prefixTree[2 * i + 1]);
            suffixTree[i] = max(suffixTree[2 * i], suffixTree[2 * i + 1]);
        }        
        vector<int> ng = nextGreater(arr, n); 
        vector<int> pg = prevGreater(arr, n); 
        bool flag = true;
 
        for (int i = 0; i < n; i++) {
            ll rightMax = query(prefixTree, 1, 0, _n - 1, i + 1, ng[i] - 1) - prefixSum[i];
            ll leftMax = query(suffixTree, 1, 0, _n - 1, pg[i] + 1, i - 1) - suffixSum[i];
            if (max(leftMax, rightMax) > 0) {
                flag = false;
                break;
            }
        }
        if (flag) 
            cout << "YESn";
        else 
            cout << "NOn";
   }
}

```
[1691E - Number of Groups](../problems/E._Number_of_Groups.md "CodeCraft-22 and Codeforces Round 795 (Div. 2)")
===========================================================================================================================

**[Video Editorial](https://codeforces.com/https://youtu.be/zHpH25DUqz4)**  
**Idea:** [amul_agrawal](https://codeforces.com/profile/amul_agrawal "Master amul_agrawal")  
**Problem Setting:** [akcube](https://codeforces.com/profile/akcube "Expert akcube") [keyurchd_11](https://codeforces.com/profile/keyurchd_11 "Candidate Master keyurchd_11") [rahulgoel](https://codeforces.com/profile/rahulgoel "Expert rahulgoel") [amul_agrawal](https://codeforces.com/profile/amul_agrawal "Master amul_agrawal")  
**Editorial**: [akcube](https://codeforces.com/profile/akcube "Expert akcube") [rahulgoel](https://codeforces.com/profile/rahulgoel "Expert rahulgoel") [keyurchd_11](https://codeforces.com/profile/keyurchd_11 "Candidate Master keyurchd_11")   
 **Video Editorial**: [akcube](https://codeforces.com/profile/akcube "Expert akcube")

 **Hint 1**We can iterate over the starting and ending points of all segments. 

 **Hint 2**Is it necessary to connect all segments which can be connected?  
Can we make observations which would reduce the number of connections we actually make?

 **Hint 3**For each group formed, it is enough to store the blue segment with maximum ending point, and red segment with maximum ending point.

 **Solution**
### [1691E - Number of Groups](../problems/E._Number_of_Groups.md "CodeCraft-22 and Codeforces Round 795 (Div. 2)")

We will be using the starting and ending points of different segments to count the final answer. We maintain a Union-Find data structure (DSU) on size n corresponding to the n segments given as input. We store all the starting and ending points in a set. (example: If 2 segments are (0,10) and (11,12), we store 0,10,11,12 in a set irrespective of the color of the segment). We now iterate through these points in ascending order. 

We maintain 2 running sets corresponding to the 2 colors. In these sets, we will store the segments for which the starting point has been reached while iterating through the set of points but the ending point hasn't been reached (ie: we store the segments that have started but not ended).

The algorithm works as follows:

If we are at a point x: 

* If it corresponds to a segment's starting point:
	+ We add that segment to the set corresponding to its color
	+ We merge (DSU merge) this segment with all segments present in the set corresponding to the other color (since their ending point hasn't been reached yet).
	+ We also erase all segments in the set corresponding to the other color except the one with the largest closing point value.
* If the point corresponds to a segment's ending point:
	+ We delete the segment from the set corresponding to its color.

Why can we delete the segments of color except for the one with the largest ending point if we encounter a starting point of the other color?

We are able to greedily pick the segment with the furthest ending point value because all segments of the same color in that set have been connected together by the segments of the other color. Hence, we can just work with the segments with the largest ending point value of both colors for each component that exists.

 **C++ Code**
```cpp
  
#include <bits/stdc++.h>
using namespace std;
 
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds; 
template <class T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
 
#define MOD 1000000007
typedef long long ll;
 
typedef pair<int, int> pii;
typedef vector<int> vi;
#define pb push_back
#define all(s) s.begin(), s.end()
#define sz(x) (int)(x).size()
#define fastio cin.tie(0) -> sync_with_stdio(0)
 
struct DSU{
    vi dsu, szx;
 
    DSU() = default;
    DSU(int n) : dsu(n), szx(n, 1) { 
        for(int i=0; i<n; i++) dsu[i] = i;
    }
    
    int parent(int i){
        if(dsu[i]==i) return i;
        else return dsu[i] = parent(dsu[i]);
    }
 
    int size(int i) { return szx[parent(i)]; }
    int operator[](int i){ return parent(i); }
    int num_comps(){
        int ct = 0;
        for(int i=0; i<sz(dsu); i++) if(dsu[i] == i) ct++;
        return ct;
    }
 
    void unify(int a, int b){
        a = parent(a);
        b = parent(b);
        if(szx[a] < szx[b]) swap(a, b);
        if(a!=b) dsu[b] = a, szx[a] += szx[b];
    }
};
 
struct Point{
    int t, p, pc, id;
    bool close;
    bool operator<(Point &other){
        if(p == other.p) return close < other.close;
        return p < other.p;
    }
};
 
void solve(){
 
    int n; cin>>n;
    vector<Point> points;
    for(int i=0; i<n; i++){
        int t, l, r; cin>>t>>l>>r;
        points.pb({t, l, r, i, false});
        points.pb({t, r, l, i, true});
    }
    sort(all(points));
 
    DSU dsu(n);
    vector<set<pii>> open(2); // {r, id}
    for(auto &p:points){
        if(p.close) open[p.t].erase({p.p, p.id});
        else{
            open[p.t].insert({p.pc, p.id});
            while(sz(open[p.t ^ 1]) > 1){
                auto [r, id] = *open[p.t ^ 1].begin();
                dsu.unify(p.id, id);
                open[p.t ^ 1].erase({r, id});
            }
            if(sz(open[p.t ^ 1]) == 1) dsu.unify(p.id, open[p.t ^ 1].begin()->second);
        }
    }
 
    cout<<dsu.num_comps()<<endl;
}
 
int main(){
    fastio;
	int t;
	cin >> t;
	while (t--) solve();   
}
```
[darkkcyan](https://codeforces.com/profile/darkkcyan "Grandmaster darkkcyan")'s solution without using sets in python.

 **Python code**
```cpp
from sys import stdin
 
def solve_case():
    n = int(stdin.readline())
    segs = [tuple(map(int, stdin.readline().split())) + (i, ) for i in range(n)]
    segs.sort(key=lambda x: x[1])
    
    par = [-1] * n
    cnt_comp = n
    def find_set(u):
        p = u
        while par[p] >= 0:
            p = par[p]
        while u != p:
            t = par[u]
            par[u] = p
            u = t
        return p
    
    def join(u, v):
        nonlocal cnt_comp
        nonlocal par
        u = find_set(u)
        v = find_set(v)
        if u == v:
            return 
        if -par[u] < -par[v]:
            u, v = v, u
        par[u] += par[v]
        par[v] = u
        cnt_comp -= 1
    
    hp = [[], []]
    
    for col, l, r, id in segs:
        for elm in hp[1 - col]:
            if elm[0] < l:
                continue
            join(elm[1], id)
        if len(hp[1 - col]):
            hp[1 - col] = [max(hp[1 - col])]
        hp[col].append((r, id))
    return cnt_comp
 
for testcase in range(int(stdin.readline())):
    print(solve_case())
```
[TheScrasse](https://codeforces.com/profile/TheScrasse "Grandmaster TheScrasse")'s nlog3n solution for E using Boruvka and Mergesort tree :D

 **Code**
```cpp
#include <bits/stdc++.h>
using namespace std;
 
#define nl "n"
#define nf endl
#define ll int
#define pb push_back
#define _ << ' ' <<
#define tm gfewnignefgo
 
#define INF (int)1e9
#define mod 998244353
#define maxn 200010
 
ll i, i1, j, k, k1, t, n, m, res, flag[10], a, b;
ll c[maxn], l[maxn], r[maxn], pr[maxn], sz[maxn];
ll tm, df[maxn];
vector<ll> adj[maxn];
vector<array<ll, 2>> nd;
vector<array<ll, 3>> cm;
priority_queue<array<ll, 2>> fn[2][maxn]; 
 
ll find(ll x) {
    if (x == pr[x]) return x;
    return pr[x] = find(pr[x]);
}
 
bool same(ll a, ll b) {
    return (find(a) == find(b));
}
 
void onion(ll a, ll b) {
    a = find(a); b = find(b);
    if (a == b) return;
    if (sz[a] < sz[b]) swap(a, b);
    pr[b] = a; sz[a] += sz[b];
}
 
void upd(ll c, ll p, ll x, ll id) {
    while (p < maxn) {
        fn[c][p].push({x, id}); p += (p & (-p));
    }
}
 
void nts(ll c, ll p, ll r, ll st) {
    ll wn = -1;
    for (; p > 0; p -= (p & (-p))) {
        while (!fn[c][p].empty()) {
            auto [rr, id] = fn[c][p].top();
            if (!df[id]) {
                fn[c][p].pop(); continue;
            }
            if (rr < r) break;
            wn = id; break;
        }
        if (wn != -1) {
            nd.pb({st, wn}); break;
        }
    }
}
 
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
 
    #if !ONLINE_JUDGE && !EVAL
        ifstream cin("input.txt");
        ofstream cout("output.txt");
    #endif
 
    // today I'm overkilling everything
    // tl;dr mst with boruvka and merge sort tree, O(n*log^3(n)), let's hope it gets ac
 
    cin >> t;
    while (t--) {
        cin >> n;
        for (i = 1; i <= 2 * n; i++) {
            while (!fn[0][i].empty()) fn[0][i].pop();
            while (!fn[1][i].empty()) fn[1][i].pop();
        }
        for (i = 1; i <= n; i++) {
            cin >> c[i] >> l[i] >> r[i];
            pr[i] = i; sz[i] = 1;
        }
 
        cm.clear(); cm.pb({-INF, 0, 0});
        for (i = 1; i <= n; i++) {
            cm.pb({l[i], i, 0}); cm.pb({r[i], i, 1});
        }
 
        sort(cm.begin(), cm.end());
        for (i = 1; i <= 2 * n; i++) {
            if (i == 1 || cm[i][0] != cm[i - 1][0]) k = i;
            if (cm[i][2] == 0) l[cm[i][1]] = k;
            else r[cm[i][1]] = k;
        }
 
        for (i = 1; i <= n; i++) {
            upd(c[i], l[i], r[i], i); df[i] = true;
        }
 
        while (true) { 
            nd.clear();
            for (i = 1; i <= n; i++) adj[i].clear(); 
            for (i = 1; i <= n; i++) adj[find(i)].pb(i);
            for (i = 1; i <= n; i++) {
                for (auto u : adj[i]) df[u] = false;
                for (auto u : adj[i]) nts(c[u] ^ 1, r[u], l[u], u);
                for (auto u : adj[i]) {
                    df[u] = true; upd(c[u], l[u], r[u], u);
                }
            }
 
            if (nd.empty()) break;
            for (auto [a, b] : nd) onion(a, b);
        }
 
        res = 0;
        for (i = 1; i <= n; i++) {
            if (find(i) == i) res++;
        }
        cout << res << nl;
    }
    return 0;
}
```
[1691F - K-Set Tree](../problems/F._K-Set_Tree.md "CodeCraft-22 and Codeforces Round 795 (Div. 2)")
======================================================================================================================

**[Video Editorial](https://codeforces.com/https://youtu.be/o8NjLKYR7iM)**  
**Idea:** [ltc.groverkss](https://codeforces.com/profile/ltc.groverkss "Master ltc.groverkss")  
**Problem Setting:** [ltc.groverkss](https://codeforces.com/profile/ltc.groverkss "Master ltc.groverkss") [amul_agrawal](https://codeforces.com/profile/amul_agrawal "Master amul_agrawal") [rahulgoel](https://codeforces.com/profile/rahulgoel "Expert rahulgoel")  
**Editorial**: [rahulgoel](https://codeforces.com/profile/rahulgoel "Expert rahulgoel")  
**Video Editorial**: [rahulgoel](https://codeforces.com/profile/rahulgoel "Expert rahulgoel")

 **Hint 1**Can we root the tree and find the partial answer for a paticular root?

 **Hint 2**The counting problem for a fixed root can be solved using combinatorics.

 **Hint 3**Can we find the answer for other roots using the calculations involved in finding answer for a fixed root in Hint 1?

 **Solution**
### [1691F - K-Set Tree](../problems/F._K-Set_Tree.md "CodeCraft-22 and Codeforces Round 795 (Div. 2)")

Our task is to calculate ∑R∈V∑S⊆V,|S|=kf(R,S) over all possible R,S. Let us first focus on all possible S just for a particular root R=r i.e. let us root our tree at r and try to find the sum ∑S⊆V,|S|=kf(R,S) just for that root.

We will calculate our answer using dynamic programming over the trees. In this technique, we will calculate some properties for each sub-tree and eventually get those properties for the entire tree.

The first property that we want to calculate for each sub-tree with node v as the sub-tree root is — cnt(v) which is the number of subsets of size k such that sub-tree of v is the minimum-size sub-tree covering it entirely. This can be calculated using combinatorics — first we calculate the total number of subsets of size k in this sub-tree and then from it we can subtract the number of subsets of size k which don't have sub-tree of v as the minimum size sub-tree. cnt(v) = {size(v) \choose k} - \sum \limits_{u \in \text{children}} {size(u) \choose k} Here, u are all the children of v and size(x) represents the size of the sub-tree of x.

This first property that we calculated is very important for us: 

* If we take the sum of cnt(v) over every node, we will get the total number of subsets of size k.
* When the tree is rooted at r, cnt(v) represents the number of subsets where sub-tree of v is the smallest sub-tree containing a set S with k vertices.
* Conclusively, f(R = r, S) = \sum \limits_{v = 1}^{n} cnt(v) \times size(v).

The second property that we want to find for each sub-tree is the size(v) — the size of the sub-tree of v.

The third property that we want to find for each sub-tree is cntsz(v) = cnt(v) \times size(v).

Now, we have f(R = r, S) (as explained above) i.e. the contribution to the final answer when the root of the entire tree is fixed at r. We can calculate the final answer by fixing other nodes as roots and then summing these value up.

Notice what happens when we try to change the root from r to one of it's children. The properties that we calculated for each sub-tree remain the same except for the old root and the new root. We can recalculate the properties for these two nodes using some clever arithmetic and get the new answer with a new root. This is known as re-rooting technique. The method to calculate the new properties are:

Note: We use OR to represent Old Root. and NR to represent New Root.

* size_{new}(OR) = size_{old}(OR) - size_{old}(NR). (Subtracting the size of this branch.)
* size_{new}(NR) = n. (This is the main root.)
* cnt_{new}(OR) = cnt_{old}(OR) - {size_{old}(OR) \choose k} + {size_{new}(OR) \choose k} + {size_{old}(NR) \choose k}. (Removing contribution of old size and putting contribution of new size. Removing contribution of the branch.)
* cnt_{new}(NR) = cnt_{old}(NR) - {size_{old}(NR) \choose k} + {size_{new}(NR) \choose k} - {size_{new}(OR) \choose k}. (Removing contribution of old size and putting contribution of new size. Putting contribution of new brach.)
* cntsz_{new}(OR) = cnt_{new}(OR) \times size_{new}(OR) (By definition.)
* cntsz_{new}(NR) = cnt_{new}(NR) \times size_{new}(NR) (By definition.)
* ans_{new} = ans_{old} - cntsz_{old}(OR) - cntsz_{old}(NR) + cntsz_{new}(OR) + cntsz_{new}(NR) (Subtracting old contribution and adding new contribution.)

The final answer is given by: finalans = \sum \limits_{v=1}^n ans_v

 **C++ Code**
```cpp
#include <iostream>
#include <vector>
 
using namespace std;
using ll = long long;
 
const ll MOD = 1e9 + 7;
 
struct Comb {
    vector<ll> fac;
    vector<ll> invfac;
    ll n;
 
    Comb(ll n)
    {
        this->n = n;
        fac.resize(n + 1, 0);
        invfac.resize(n + 1, 0);
 
        fac[0] = 1;
        for (ll i = 1; i <= n; i++)
            fac[i] = (fac[i - 1] * i) % MOD;
        invfac[n] = power(fac[n], MOD - 2);
        for (ll i = n - 1; i >= 0; i--)
            invfac[i] = (invfac[i + 1] * (i + 1)) % MOD;
    }
 
    static ll power(ll x, ll y)
    {
        ll ret = 1;
        while (y) {
            if (y & 1)
                ret = (ret * x) % MOD;
            y >>= 1;
            x = (x * x) % MOD;
        }
        return ret;
    }
 
    ll nCr(ll n, ll r)
    {
        if (n < 0 or r < 0 or n < r)
            return 0;
        ll ans = (fac[n] * ((invfac[r] * invfac[n - r]) % MOD)) % MOD;
        return ans;
    }
};
 
vector<vector<int> > adj;
vector<int> sz;
vector<ll> cnt;
vector<ll> cntsz;
 
Comb C(2e5 + 5);
 
ll cur_ans = 0;
ll ans = 0;
 
void dfs1(int v, int p, int k)
{
    sz[v] = 1;
    ll sub = 0;
 
    for (int u : adj[v]) {
        if (u != p) {
            dfs1(u, v, k);
            sz[v] += sz[u];
            sub = (sub + C.nCr(sz[u], k)) % MOD;
        }
    }
 
    cnt[v] = (C.nCr(sz[v], k) - sub + MOD) % MOD;
    cntsz[v] = (cnt[v] * sz[v]) % MOD;
    cur_ans = (cur_ans + cntsz[v]) % MOD;
}
 
void dfs2(int v, int p, int k)
{
    ans = (ans + cur_ans) % MOD;
    for (int u : adj[v]) {
        if (u != p) {
            // store
            int store_v_sz = sz[v];
            ll store_v_cnt = cnt[v];
            ll store_v_cntsz = cntsz[v];
            int store_u_sz = sz[u];
            ll store_u_cnt = cnt[u];
            ll store_u_cntsz = cntsz[u];
            ll store_cur_ans = cur_ans;
 
            // recalculate size[v], size[u]
            sz[v] -= sz[u];
            sz[u] = sz.size();
 
            // recalculate cnt[v]
            cnt[v] = (cnt[v] - C.nCr(store_v_sz, k) + MOD) % MOD;
            cnt[v] = (cnt[v] + C.nCr(sz[v], k)) % MOD;
            cnt[v] = (cnt[v] + C.nCr(store_u_sz, k)) % MOD;
 
            // recalculate cnt[u]
            cnt[u] = (cnt[u] - C.nCr(store_u_sz, k) + MOD) % MOD;
            cnt[u] = (cnt[u] + C.nCr(sz[u], k)) % MOD;
            cnt[u] = (cnt[u] - C.nCr(sz[v], k) + MOD) % MOD;
 
            // recalculate cntsz
            cntsz[v] = (cnt[v] * sz[v]) % MOD;
            cntsz[u] = (cnt[u] * sz[u]) % MOD;
 
            // recalculate cur_ans
            cur_ans = (cur_ans - store_v_cntsz - store_u_cntsz + MOD + MOD) % MOD;
            cur_ans = (cur_ans + cntsz[v] + cntsz[u]) % MOD;
 
            dfs2(u, v, k);
 
            // restore
            sz[v] = store_v_sz;
            cnt[v] = store_v_cnt;
            cntsz[v] = store_v_cntsz;
            sz[u] = store_u_sz;
            cnt[u] = store_u_cnt;
            cntsz[u] = store_u_cntsz;
            cur_ans = store_cur_ans;
        }
    }
}
 
int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
 
    int n, k;
    cin >> n >> k;
 
    adj.resize(n);
    sz.resize(n);
    cnt.resize(n);
    cntsz.resize(n);
 
    for (int i = 0; i < n - 1; ++i) {
        int u, v;
        cin >> u >> v;
        --u, --v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
 
    dfs1(0, 0, k);
    dfs2(0, 0, k);
 
    cout << ans << endl;
    return 0;
}

```
