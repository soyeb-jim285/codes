# Tutorial_(ru)


### [1531A - Зингер | color](../problems/A._Зингер_|_color.md "VK Cup 2021 - Квалификация (Engine)")

Для решения этой задачи достаточно промоделировать операции, описанные в условии. Например, можно использовать переменную color типа string, содержащую текущий цвет купола, и переменную locked типа boolean, обозначающую, заблокировано ли сейчас изменение цвета.

Пример решения на Python:


```cpp
n = int(input())  
color = "blue"  
locked = False  
for i in range(n):  
  msg = input()  
  if msg == "lock":  
    locked = True  
  elif msg == "unlock":  
    locked = False  
  elif not locked:  
    color = msg  
print(color)  

```
 
### [1531B1 - Мониторинг](../problems/B1._Мониторинг.md "VK Cup 2021 - Квалификация (Engine)")

В первой подзадаче достаточно перебрать все пары мониторов и проверить заданное условие. Пара мониторов $(i, j)$ подходящая, если любое из чисел $w_i, h_i$ равно любому из чисел $w_j, h_j$.

Пример решения на Python:


```cpp
n = int(input())  
w = [0 for i in range(n)]  
h = [0 for i in range(n)]  
for i in range(n):  
  w[i], h[i] = map(int, input().split())  
  
ans = 0  
for i in range(n):  
  for j in range(i + 1, n):  
    if w[i] == w[j] or w[i] == h[j] or h[i] == w[j] or h[i] == h[j]:  
      ans += 1  
  
print(ans)  

```
Такой алгоритм имеет сложность $O(n^2)$ и недостаточно эффективен для второй подзадачи.

 Tutorial is loading... 
### [1531C - Симметричный амфитеатр](../problems/C._Симметричный_амфитеатр.md "VK Cup 2021 - Квалификация (Engine)")

Найдём минимальное $k$ такое, что $k^2 \ge n$. Понятно, что минимальный размер схемы $m$ не может быть меньше $k$.

Попробуем нарисовать схему с $m = k$. Для этого заполним полностью квадратами схему со стороной $k$, а потом заберём $x = k^2 - n$ квадратов, чтобы схема осталась корректной. Поскольку мы взяли именно минимальное $k$, достаточно рассмотреть $x < k^2 - (k-1)^2 = 2k-1$.

Если $x = 0$, можно ничего не забирать. Например, при $k = 6$ схема для $n = 36$ выглядит так:


```cpp
oooooo  
oooooo  
oooooo  
oooooo  
oooooo  
oooooo  
  

```
Если $x = 1, 3, 5, \ldots, 2k-3$, можно забрать квадрат в правом верхнем углу, а дальше забирать параллельно по одному квадрату из верхней строки и правого столбца. Например, при $k = 6$ схемы для $n = 35, 33, 31, 29, 27$ могут выглядеть так:


```cpp
ooooo.      oooo..      ooo...      oo....      o.....  
oooooo      ooooo.      ooooo.      ooooo.      ooooo.  
oooooo      oooooo      ooooo.      ooooo.      ooooo.  
oooooo      oooooo      oooooo      ooooo.      ooooo.  
oooooo      oooooo      oooooo      oooooo      ooooo.  
oooooo      oooooo      oooooo      oooooo      oooooo  
  

```
Если $x = 4, 6, 8, \ldots, 2k-2$, можно забрать квадрат $2 \times 2$ в правом верхнем углу, а дальше, аналогично предыдущему случаю, забирать по одному квадрату из верхней строки и правого столбца. Например, при $k = 6$ схемы для $n = 32, 30, 28, 26$ могут выглядеть так:


```cpp
oooo..      ooo...      oo....      o.....  
oooo..      oooo..      oooo..      oooo..  
oooooo      ooooo.      ooooo.      ooooo.  
oooooo      oooooo      ooooo.      ooooo.  
oooooo      oooooo      oooooo      ooooo.  
oooooo      oooooo      oooooo      oooooo  
  

```
Наконец, если $x = 2$, забрать два квадрата из полностью заполненной схемы $k \times k$ с сохранением условий не получится. В таком случае придётся увеличить размер схемы до $m = k+1$, а построить такую схему можно, например, забрав четыре квадрата из заполненной схемы размера $k \times k$ и добавив по одному квадрату в левый верхний и правый нижний углы. Например, при $k = 6$ схема для $n = 34$ может выглядеть так:


```cpp
o......  
oooo...  
oooo...  
oooooo.  
oooooo.  
oooooo.  
ooooooo  
  

```
Построение в последнем случае работает только при $k \ge 3$, поскольку забрать четыре квадрата из схемы $2 \times 2$ нельзя. В случае $n = 2$, когда $x = 2$ и $k = 2$, решения не существует и нужно вывести $-1$.

Пример решения на Python:


```cpp
def build(n):  
  if n == 2:  
    return []  
    
  k = 1  
  while k * k < n:  
    k += 1  
  x = k * k - n  
    
  if x == 2:  
    s = build(n - 2)  
    s = [['.'] * k] + s  
    for row in s:  
      row.append('.')  
    s[0][0] = s[-1][-1] = 'o'  
    return s  
  
  s = [['o'] * k for i in range(k)]  
    
  if x % 2 == 1:  
    s[0][-1] = '.'  
    for i in range((x - 1) // 2):  
      s[0][-2 - i] = s[1 + i][-1] = '.'  
  
  if x % 2 == 0 and x >= 4:  
    s[0][-1] = s[1][-1] = s[0][-2] = s[1][-2] = '.'  
    for i in range((x - 4) // 2):  
      s[0][-3 - i] = s[2 + i][-1] = '.'  
  
  return s  
  
n = int(input())  
s = build(n)  
if s == []:  
  print(-1)  
else:  
  print(len(s))  
  for row in s:  
    print("".join(row))  

```
 
### [1531D - Редактируем Зингер | color](../problems/D._Редактируем_Зингер_|_color.md "VK Cup 2021 - Квалификация (Engine)")

Если после каждой операции редактирования заново проходить по всей истории сообщений, сложность составит $O(tn)$ и решение не уложится в лимит времени. Рассмотрим более эффективный подход.

Для простоты добавим в начало хронологии сообщения unlock и blue, которые никогда не будут редактироваться, а в конец — сообщение lock.

Назовём сообщение unlock полезным, если следующее после него в хронологическом порядке сообщение содержит цвет. Можно заметить, что меняют цвет купола те и только те «цветные» сообщения, которые идут подряд непосредственно после полезных unlock'ов. Основываясь на этом факте, можно определить итоговый цвет купола так:

1. Найти последний полезный unlock. Обозначим его позицию через $p$. (Хотя бы один полезный unlock существует, так как мы добавили в начало сообщения unlock и blue.)
2. Найти следующий после позиции $p$ lock или unlock. Обозначим его позицию через $q$.
3. Сообщение $q-1$ содержит искомый цвет.

Будем поддерживать два упорядоченных множества — множество $a$, содержащее позиции всех полезных unlock'ов, и множество $b$, содержащее позиции всех lock'ов и unlock'ов вместе взятых. 

После редактирования сообщения $i$ нужно добавить в множества или удалить из них только позиции $i$ и $i-1$, а затем определить новый цвет купола по описанной выше последовательности действий. Соответственно, всего нужно выполнить $O(1)$ операций с множествами.

От множеств нам нужно эффективное выполнение операций добавления, удаления, поиска, взятия максимального элемента, и взятия следующего в отсортированном порядке элемента. С этим справится любое сбалансированное дерево поиска. Можно воспользоваться встроенными во многие языки структурами данных: например, в C++ подойдёт std::set, в Java — TreeSet. Такие структуры выполняют требуемые операции за $O(\log n)$.

Итоговая сложность решения составляет $O(t \log n)$.

Пример решения на C++:


```cpp
#include <iostream>  
#include <vector>  
#include <set>  
  
using namespace std;  
  
int n;  
vector<string> s;  
set<int> a;  
set<int> b;  
  
void Update(int i) {  
  a.erase(i);  
  if (i + 1 < n && s[i] == "unlock" && s[i + 1] != "unlock" && s[i + 1] != "lock") {  
    a.insert(i);  
  }  
  b.erase(i);  
  if (s[i] == "unlock" || s[i] == "lock") {  
    b.insert(i);  
  }  
}  
  
string GetResult() {  
  int p = *prev(a.end());  
  int q = *next(b.find(p));  
  return s[q - 1];  
}  
  
int main() {  
  cin >> n;  
  n += 3;  
  s.resize(n);  
  s[0] = "unlock";  
  s[1] = "blue";  
  for (int i = 2; i < n - 1; i++) {  
    cin >> s[i];  
  }  
  s[n - 1] = "lock";  
  for (int i = 0; i < n; i++) {  
    Update(i);  
  }  
  cout << GetResult() << endl;  
  int tt;  
  cin >> tt;  
  for (int i = 0; i < tt; i++) {  
    int id;  
    cin >> id;  
    id += 1;  
    cin >> s[id];  
    Update(id - 1);  
    Update(id);  
    cout << GetResult() << endl;  
  }  
  return 0;  
}  

```
 
### [1531E2 - Сортировка слиянием](../problems/E2._Сортировка_слиянием.md "VK Cup 2021 - Квалификация (Engine)")

Предположим, что мы знаем длину перестановки $n$.

Исходно перестановка имела вид $a_0, a_1, \ldots, a_{n-1}$. Давайте попробуем её отсортировать, используя рекурсивную функцию из условия.

Единственная проблема, с которой мы столкнёмся — мы не знаем значения элементов, поэтому не умеем выполнять сравнение в строке if a[i] < a[j]. Здесь нам и поможет лог сравнений.

Как только нам приходит запрос на сравнение элемента, обратимся к очередному символу лога. Таким образом мы узнаем, какой из элементов a[i] и a[j] на самом деле меньше, и запишем его в b[k].

По итогам сортировки на первом месте окажется элемент со значением $1$, на втором — со значением $2$, и так далее. Например, если после сортировки при $n = 6$ перестановка примет вид $a_3, a_5, a_2, a_0, a_1, a_4$, значит, исходная перестановка равна $4, 5, 3, 1, 6, 2$.

Вспомним, что длину перестановки мы не знаем. Давайте её переберём в диапазоне от $1$ до $10^3$. Если по итогам сортировки будут использованы не все символы лога, или же нам потребуется взять символ из лога, когда их там уже не останется, значит, такое значение $n$ нам не подходит. Если же мы использовали ровно столько символов из лога, сколько нам дано, то мы нашли корректный ответ.

Проверка одного значения $n$ выполняется за $O(n \log n)$, следовательно, итоговая сложность составит $O(n^2 \log n)$.

 
### [1531E3 - Сортировка слиянием](../problems/E3._Сортировка_слиянием.md "VK Cup 2021 - Квалификация (Engine)")

Чтобы ускорить решение, вместо линейного поиска по $n$ будем использовать бинарный.

Оказывается, что если по итогам сортировки при некотором $n$ использованы не все символы лога, значение $n$ точно нужно увеличить. Аналогично, если нам требуется взять символ из лога, когда их там уже не осталось, значение $n$ точно нужно уменьшить.

Как это доказать? Посмотрим на длины сортируемых отрезков перестановки в том порядке, в котором информация о них записана в логе. Например, при $n = 8$ получим последовательность $2, 2, 4, 2, 2, 4, 8$.

Увеличим $n$ на единицу. Заметим, что в дереве рекурсии произойдут следующие изменения: на некотором пути от корня до листа все длины отрезков увеличатся на $1$, а также появятся два новых листа. С точки зрения последовательности длин, описанной выше, изменения будут следующие: некоторые длины увеличатся на $1$, а также появится новый отрезок длины $2$. Например, при $n = 9$ получим последовательность $2, 2, 4, 2, \underline{3}, \mathit{2}, \underline{5}, \underline{9}$. Подчёркнуты увеличившиеся числа, а курсивом выделено новое число.

Для слияния на отрезке длины $k$ мы используем символы из лога, пока не встретим хотя бы $\lfloor \frac{k}{2} \rfloor$ нулей или хотя бы $\lceil \frac{k}{2} \rceil$ единиц. Пусть мы начали обработку отрезка длины $k$, находясь в логе на позиции $l$, а закончили на позиции $r$. Заметим, что если мы начнём на позиции $l' \ge l$, то закончим на позиции $r' \ge r$. Кроме того, если увеличить $k$, позиция конца также не может уменьшиться.

Так как при увеличении $n$ в последовательности длин отрезков не поменялся относительный порядок, а только увеличились некоторые элементы и добавились новые, можно видеть, что позиция, на которой мы закончим обработку лога, может сдвинуться только вправо. Следовательно, по величине $n$ можно выполнить бинарный поиск.

Проверка одного значения $n$ всё ещё выполняется за $O(n \log n)$, но в процессе бинарного поиска мы проверим только $O(\log n)$ различных значений, поэтому итоговая сложность составит $O(n \log^2 n)$.

Пример решения на Python:


```cpp
def tryN(n, log):  
  a = [i for i in range(n)]  
  b = [0 for i in range(n)]  
  ptr = 0  
  
  def mergeSort(l, r):  
    if r - l <= 1:  
      return  
    nonlocal ptr  
    m = (l + r) >> 1  
    mergeSort(l, m)  
    mergeSort(m, r)  
    i, j, k = l, m, l  
    while i < m and j < r:  
      if ptr >= len(log):  
        ptr += 1  
        return  
      if log[ptr] == '0':  
        b[k] = a[i]  
        i += 1  
      else:  
        b[k] = a[j]  
        j += 1  
      ptr += 1  
      k += 1  
    while i < m:  
      b[k] = a[i]  
      i += 1  
      k += 1  
    while j < r:  
      b[k] = a[j]  
      j += 1  
      k += 1  
    for p in range(l, r):  
      a[p] = b[p]  
  
  mergeSort(0, n)  
  if ptr == len(log):  
    res = [0 for i in range(n)]  
    for i in range(n):  
      res[a[i]] = i + 1  
    print(n)  
    print(' '.join(map(str, res)))  
    exit()  
  return ptr  
  
s = input()  
low = 1  
high = len(s) + 1  
while low <= high:  
  mid = (low + high) // 2  
  ptr = tryN(mid, s)  
  if ptr < len(s):  
    low = mid + 1  
  else:  
    high = mid - 1  

```
